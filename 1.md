### **Solutions for Exam Paper: 221 term**

---

#### **Section A: Short Questions**

**1. Define the term "algorithm" in the context of computer programming.**

An **algorithm** is a step-by-step, well-defined procedure or technique for solving a specific problem. In computer programming, it refers to the logic of a program and provides a sequential description of how to arrive at a solution. An algorithm must be finite, meaning it will eventually terminate after a set number of steps.

**2. What is the difference between an array and a pointer in C?**

| Feature | Array | Pointer |
| :--- | :--- | :--- |
| **Definition** | A collection of elements of the same data type stored in contiguous memory locations. | A variable that stores the memory address of another variable of the same data type. |
| **Storage** | Stores the actual data values. | Stores the address (memory location) of a data value. |
| **Declaration** | `data_type array_name[size];` | `data_type *pointer_name;` |
| **Memory** | Memory is allocated at compile time (static allocation). | Can be used for both static and dynamic memory allocation (e.g., using `malloc`). |
| **Access** | Elements are accessed using an index, e.g., `array[i]`. | The value at the stored address is accessed using the indirection operator (`*`), e.g., `*ptr`. |

**3. What is the difference between "while" and "do-while" loops in C?**

The main difference lies in when the loop condition is checked.
*   A **`while` loop** is an **entry-controlled loop**. The condition is tested *before* the body of the loop is executed. If the condition is false initially, the loop body will not execute even once.
*   A **`do-while` loop** is an **exit-controlled loop**. The condition is tested *after* the body of the loop is executed. This guarantees that the loop body will be executed at least once, regardless of the condition.

**Syntax Difference:** A `do-while` loop has a semicolon at the end of the `while(condition);` statement, whereas a `while` loop does not.

**4. Explain the difference between the "++i" and "i++" increment operators in C.**

Both `++i` (pre-increment) and `i++` (post-increment) increase the value of the variable `i` by one. The difference is in the value they return within an expression.
*   **Pre-increment (`++i`):** The value of `i` is incremented *first*, and then the new, incremented value is used in the expression.
*   **Post-increment (`i++`):** The *current* value of `i` is used in the expression first, and then the value of `i` is incremented.

**Example:**
```c
int i = 5, a, b;
a = ++i; // i becomes 6, then a is assigned 6. Result: a=6, i=6
b = i++; // b is assigned 6, then i becomes 7. Result: b=6, i=7
```

**5. Define break statement and continue statement.**

*   **`break` statement:** When encountered inside a loop (`for`, `while`, `do-while`) or a `switch` case, the `break` statement immediately terminates the loop or `switch` and transfers control to the statement immediately following the loop or `switch`.
*   **`continue` statement:** When encountered inside a loop, the `continue` statement skips the rest of the current iteration and begins the next iteration of the loop. It does not terminate the loop entirely.

**6. How does an array variable differ from an ordinary variable?**

An **ordinary variable** is a data storage location that can hold a single value of a specific data type (e.g., `int x = 10;`).

An **array variable**, on the other hand, is a collection of multiple values, all of the same data type, stored sequentially in memory. It acts as a single named entity that represents a group of related variables. For example, `int marks[5];` declares a variable named `marks` that can hold five separate integer values, accessed via an index (e.g., `marks[0]`, `marks[1]`, etc.).

**7. What is the purpose of the 'getchar' function? How is it used within a C program?**

The purpose of the `getchar()` function is to read a single character from the standard input (usually the keyboard). It is often used repeatedly in a loop to read an entire line of text, character by character, until a specific character (like the newline character `\n`) is encountered.

**Usage Example (from page 127):**
```c
#include<stdio.h>
void main() {
    char character;
    printf("Enter a character: ");
    character = getchar(); // Reads one character
    printf("You entered: %c\n", character);
}
```

**8. Differentiate between local variable and global variable.**

| Feature | Local Variable | Global Variable |
| :--- | :--- | :--- |
| **Declaration** | Declared inside a function or a block `{}`. | Declared outside of all functions, typically at the top of the program. |
| **Scope** | Its scope is limited to the function or block in which it is declared. It cannot be accessed outside of it. | Its scope is the entire program. It can be accessed and modified by any function in the file. |
| **Lifetime** | Created when the function/block is entered and destroyed when the function/block is exited. | Exists for the entire duration of the program's execution. |
| **Default Value** | Contains an unpredictable "garbage" value if not explicitly initialized. | Initialized to zero by default if not explicitly initialized. |

**9. What are the basic differences between function and procedure?**

In general programming terminology, a **procedure** is a set of instructions to perform a task, while a **function** is a procedure that returns a value.

However, the C programming language does not have a separate keyword for "procedure". **In C, both concepts are implemented as functions.**
*   A function that returns a value has a specific return type (e.g., `int`, `float`).
*   A function that does not return a value (acting like a traditional procedure) is declared with a `void` return type.

So, the basic difference in C is whether the function is declared with `void` or a specific data type as its return value.

**10. Write the concept of "function" in programming.**

A **function** is a self-contained, reusable block of code that performs a specific, well-defined task. It is a fundamental building block in C programming. Functions help in modularizing a program by breaking down a large, complex problem into smaller, manageable, and logical parts. A function can accept inputs (called arguments or parameters), perform computations, and can optionally return a single value as its result. Every C program must have at least one function, `main()`, which is the entry point for program execution.

---

#### **Section B: Analytical Questions**

**1. Describe the basic structure of a C program, including the role of header files, main function, and syntax.**

The basic structure of a C program consists of several key components:

1.  **Header Files (`#include`):** These are files that contain declarations for pre-defined functions and macros. The `#include` directive tells the pre-processor to include the contents of a specified file in the program before compilation. For example, `#include <stdio.h>` is used to include the Standard Input/Output library, which provides functions like `printf()` and `scanf()`.

2.  **The `main()` Function:** This is the most crucial part of any C program. Program execution always begins with the `main()` function. Every C program must have exactly one `main()` function. The code to be executed is placed within its curly braces `{}`. It typically has a return type of `int`, and `return 0;` at the end signifies that the program has executed successfully.

3.  **Statements:** These are the instructions that perform specific actions. Each statement in C must end with a semicolon (`;`), which acts as a statement terminator. Examples include declaration statements (`int a;`), assignment statements (`a = 10;`), and function calls (`printf("Hello");`).

4.  **Comments (`/* ... */`):** Comments are explanatory text ignored by the compiler. They are used to make the code more readable and understandable for humans. They can appear almost anywhere in the code.

5.  **Braces (`{` and `}`):** Curly braces are used to define a block of code. The body of every function must be enclosed in braces. They are also used to group statements in control structures like `if`, `else`, and loops.

**Example Structure:**
```c
/* A simple C program (Comment) */
#include <stdio.h> // Header file inclusion

int main() // The main function
{ // Start of main function block
    // Statements are written here
    printf("Welcome to C"); // A library function call statement
    
    return 0; // Return statement
} // End of main function block
```

**2. Write the concept of "recursion" in programming. Explain how recursion works and provide an example of a recursive function in C.**

**Concept of Recursion:**
Recursion is a programming technique where a function calls itself, either directly or indirectly, to solve a problem. A recursive solution breaks a problem down into smaller, simpler versions of the same problem until it reaches a point where the solution is trivial.

**How Recursion Works:**
A recursive function must have two essential parts:
1.  **Base Case:** This is the condition under which the function stops calling itself. It is the simplest form of the problem that can be solved directly without further recursion. Without a base case, the function would call itself indefinitely, leading to a stack overflow error.
2.  **Recursive Step:** In this part, the function calls itself with a modified argument that moves it closer to the base case. The function performs some operation and then breaks the problem down into a smaller sub-problem.

**Example: Factorial of a Number**
The factorial of a non-negative integer `n` (denoted as `n!`) is the product of all positive integers up to `n`.
e.g., `5! = 5 * 4 * 3 * 2 * 1`.
This can be defined recursively:
*   `n! = n * (n-1)!` (Recursive Step)
*   `1! = 1` (Base Case)

**Recursive Function in C (Factorial):**
```c
#include <stdio.h>

// Function prototype
int factorial(int n);

int main() {
    int num = 5;
    printf("Factorial of %d is %d\n", num, factorial(num));
    return 0;
}

// Recursive function definition
int factorial(int n) {
    // Base Case: if n is 1, stop recursion
    if (n == 1) {
        return 1;
    }
    // Recursive Step: call factorial with a smaller number
    else {
        return (n * factorial(n - 1));
    }
}
```
*   **Reference:** The code is adapted from the factorial example on **page 164**.

**3. Write a program which takes an input from the keyboard and to find the factorial of a given number using recursion.**

This is the complete, runnable version of the program based on the example in the textbook.

```c
#include <stdio.h>
#include <conio.h>

// Function prototype for the recursive function
int factorial(int n);

void main() {
    int num, f;
    
    clrscr(); // Clears the screen
    
    printf("\nEnter a number: ");
    scanf("%d", &num);
    
    // Call the recursive function
    f = factorial(num);
    
    printf("\nFactorial value of %d is: %d", num, f);
    getch(); // Waits for a key press
}

// Recursive function definition to calculate factorial
int factorial(int n) {
    // Base case: Factorial of 1 is 1
    if (n == 1) {
        return 1;
    }
    // Recursive step: n * factorial of (n-1)
    else {
        return (n * factorial(n - 1));
    }
}
```
**Sample Output:**
```
Enter a number: 6
Factorial value of 6 is: 720
```

**4. What is meant by function argument, function call and return value? Explain with example.**

*   **Function Argument (or Parameter):** An argument is a value that is passed *to* a function when it is called. These values are used by the function to perform its task. There are two types:
    *   **Actual Arguments:** The values passed in the function call (e.g., `10`, `5` in `sum(10, 5);`).
    *   **Formal Arguments:** The variables in the function definition that receive the values (e.g., `int a, int b` in `int sum(int a, int b)`).

*   **Function Call:** This is the statement that executes a function. It consists of the function's name followed by parentheses containing the actual arguments. A function call transfers the program's control to the called function.

*   **Return Value:** A function can send a single value back to the part of the program that called it. This is done using the `return` keyword. The data type of the returned value must match the function's declared return type.

**Example:**
```c
#include <stdio.h>

// Function prototype
// 'int a' and 'int b' are formal arguments
// The first 'int' is the return type
int add(int a, int b);

int main() {
    int result;
    // Function Call with actual arguments 10 and 5
    result = add(10, 5);
    
    printf("The result is: %d\n", result);
    return 0;
}

// Function definition
int add(int a, int b) {
    int sum = a + b;
    // 'sum' is the return value
    return sum;
}
```

**5. Why are procedures used in writing computer programs?**

As noted earlier, C uses "functions" for what other languages might call "procedures". Therefore, this question is asking about the benefits of using functions. The primary reasons for using functions are:

1.  **Modularity:** Functions allow a large program to be broken down into smaller, more manageable, and logical sub-programs. This makes the code easier to design, write, and understand.
2.  **Reusability:** A function can be written once and then called multiple times from different parts of the program, or even used in other programs. This saves time and reduces code duplication.
3.  **Debugging and Maintenance:** When a program is modular, it is easier to locate and fix errors (bugs). A bug can be isolated to a specific function. Similarly, updating or improving a part of the program only requires modifying a single function rather than searching through a large block of code.
4.  **Abstraction:** Functions hide the complexity of a task. When you call a function like `printf()`, you don't need to know *how* it works internally; you only need to know what it does and what arguments to provide.

**6. What is string constant? How does string constant differ from character constant?**

A **string constant** (also called a string literal) is a sequence of zero or more characters enclosed in **double quotes (`" "`)**. For example: `"Bangladesh Open University"`. The compiler automatically adds a null character (`\0`) at the end of every string constant to mark its termination.

A **character constant** is a single character enclosed in **single quotes (`' '`)**. For example: `'A'`, `'5'`, `'\n'`.

| Feature | String Constant | Character Constant |
| :--- | :--- | :--- |
| **Delimiters** | Double quotes (`" "`) | Single quotes (`' '`) |
| **Content** | A sequence of characters. Can be empty. | A single character. |
| **Termination** | Automatically terminated by a null character (`\0`). | Not terminated by a null character. |
| **Data Type** | Treated as an array of characters (`char[]`). | Treated as an integer (`int`) type in C. |
| **Example** | `"Hello"` | `'H'` |

**7. Describe the difference between "pass-by-value" and "pass-by-reference" in C function parameter passing.**

The textbook does not use the explicit terms "pass-by-value" and "pass-by-reference", but it describes the mechanisms.

*   **Pass-by-Value:** This is the default method of passing arguments to functions in C. When an argument is passed by value, a **copy** of the argument's value is made and passed to the function. The function works with this copy. Any changes made to the parameter inside the function **do not affect** the original variable in the calling function.

*   **Pass-by-Reference (Simulated in C):** C does not directly support pass-by-reference. Instead, it is **simulated using pointers**. To achieve this, the **memory address** of the original variable is passed to the function. The function then declares a pointer to receive this address. By using the indirection operator (`*`), the function can directly access and modify the value of the original variable at that memory location. Changes made inside the function **will affect** the original variable.

**Example:**
```c
#include <stdio.h>

void modifyByValue(int x);
void modifyByReference(int *y);

int main() {
    int a = 10, b = 10;
    
    modifyByValue(a); // Pass by value
    printf("Value of 'a' after modifyByValue: %d\n", a); // Prints 10
    
    modifyByReference(&b); // Pass address (simulate pass-by-reference)
    printf("Value of 'b' after modifyByReference: %d\n", b); // Prints 20
    
    return 0;
}

void modifyByValue(int x) {
    x = 20; // Modifies the local copy only
}

void modifyByReference(int *y) {
    *y = 20; // Modifies the original value at the address
}
```

**8. Explain common debugging techniques and error handling mechanisms in C.**

**Debugging Techniques** are methods used to find and fix errors (bugs) in a program.

1.  **Print Statements (`printf` Debugging):** This is the simplest technique. Programmers insert `printf()` statements at various points in the code to print the values of variables. This helps track the program's flow and see where a variable gets an incorrect value.
2.  **Using a Debugger:** A debugger is a tool (like GDB) that allows you to run a program step-by-step. You can execute the code line by line, inspect the values of variables at any point, set "breakpoints" to pause execution at specific lines, and analyze the call stack.
3.  **Code Reviews:** Having another programmer look at your code can often help spot logical errors or typos that you might have missed.

**Error Handling Mechanisms** are ways to anticipate and manage errors during program execution.

1.  **Return Codes:** Functions can return specific values to indicate success or failure. For example, a function might return `0` on success and `-1` on error. The calling code must check this return value and act accordingly.
2.  **Global Error Variables:** C provides a global variable called `errno` (in `errno.h`). Many standard library functions set `errno` to a specific error code when they fail. The `perror()` function can be used to print a human-readable message corresponding to the current `errno` value.
3.  **Input Validation:** Always check user input to ensure it is in the expected format and range. For instance, if you ask for a positive number, check if the input is actually positive before using it in calculations.

***

### **Solutions for Exam Paper: 191 term**

Many questions here are similar to the previous exam.

---

#### **Section A: Short Questions**

1.  **Draw a flowchart to multiply two numbers entered by user.**
    ```
    ┌───────────┐
    │   Start   │
    └───────────┘
          ↓
    ┌────────────────┐
    │ Input Num1, Num2 │
    └────────────────┘
          ↓
    ┌─────────────────────┐
    │ Product = Num1 * Num2 │
    └─────────────────────┘
          ↓
    ┌────────────────┐
    │  Output Product  │
    └────────────────┘
          ↓
    ┌───────────┐
    │    End    │
    └───────────┘
    ```

2.  **Why use return statement in C programming language?**
    The `return` statement is used in a C function for two main purposes:
    1.  To immediately exit the current function and transfer program control back to the function that called it.
    2.  To pass a value back from the function to the calling function. The data type of the returned value must match the function's declared return type. A function declared with `void` return type does not return a value.

3.  **Define local variable and global variable.**
    (This is the same as Question 8 from the first exam paper. See answer above.)

4.  **What are the keywords in C? What restrictions apply to their use?**

    **Keywords** are pre-defined, reserved words in the C language that have special meanings to the compiler. These words cannot be changed by the programmer. Examples include `int`, `float`, `if`, `else`, `for`, `while`, `return`, and `struct`.

    **Restriction:** The main restriction is that **keywords cannot be used as names for identifiers**, such as variable names, function names, or structure names. For example, you cannot declare a variable named `int`.

5.  **What happens when we run a program containing a switch?**

    When a program executes a `switch` statement, the value of its expression (an integer or character) is evaluated. The program then compares this value sequentially against the values in the `case` labels.
    *   If a match is found, the program control jumps to the block of code associated with that `case`.
    *   The program executes statements from that point onwards until it encounters a `break` statement or the end of the `switch` block.
    *   If no `case` value matches the expression and a `default` label exists, the code under `default` is executed.
    *   If no match is found and there is no `default` case, the entire `switch` block is skipped.

6.  **Why continue statement are use in C? Give an example of continue statement.**

    The `continue` statement is used inside a loop to skip the remaining part of the current iteration and immediately proceed to the next iteration. It is useful when you want to bypass a part of the loop's body for certain conditions without terminating the loop entirely.

    **Example:** Print only odd numbers from 1 to 10.
    ```c
    #include <stdio.h>
    void main() {
        int i;
        for(i = 1; i <= 10; i++) {
            // If i is even, skip this iteration
            if (i % 2 == 0) {
                continue;
            }
            printf("%d ", i);
        }
    }
    ```
    **Output:** `1 3 5 7 9`

7.  **What is pointer notation?**

    Pointer notation refers to the syntax used in C to declare and use pointers. The key symbols are:
    *   **Asterisk `*` (Declaration):** Used to declare a pointer variable. For example, `int *ptr;` declares `ptr` as a pointer to an integer.
    *   **Ampersand `&` (Address-of operator):** Used to get the memory address of a variable. For example, `ptr = &var;` assigns the address of `var` to `ptr`.
    *   **Asterisk `*` (Indirection/Dereference operator):** Used to access the value stored at the address held by the pointer. For example, `value = *ptr;` assigns the value at the address `ptr` is pointing to.

8.  **Write the definition and use of a function.**

    **Definition:** A function is a self-contained block of code that performs a specific task. It can take inputs (arguments) and optionally return a single value.
    **Use:** Functions are used to achieve modularity, code reusability, and abstraction. They break a large program into smaller, manageable pieces, making the code easier to write, read, debug, and maintain.

9.  **Write a C program to determine whether a year is leap year or not.**

    ```c
    #include <stdio.h>
    
    int main() {
        int year;
        printf("Enter a year: ");
        scanf("%d", &year);
    
        // A year is a leap year if it is divisible by 4,
        // unless it is a century year (divisible by 100).
        // Century years are leap years only if they are divisible by 400.
        if ((year % 400 == 0) || (year % 100 != 0 && year % 4 == 0)) {
            printf("%d is a leap year.\n", year);
        } else {
            printf("%d is not a leap year.\n", year);
        }
        return 0;
    }
    ```

10. **What is the main functionality of array?**

    The main functionality of an array is to store a fixed-size, sequential collection of elements of the **same data type** under a single variable name. It allows for efficient storage and access of a large number of related data items, which can be easily manipulated using loops.

---

#### **Section B: Analytical Questions**

1.  **How to differentiate while and do while statement? Explain it with proper example.**

    (This is the same as Question 3 from the first exam's Section A, but requires an example.)
    
    The primary difference is that `while` is an **entry-controlled loop** and `do-while` is an **exit-controlled loop**.
    *   A `while` loop checks its condition *before* executing its body.
    *   A `do-while` loop executes its body *once*, and then checks its condition.

    **Example:**
    ```c
    #include <stdio.h>
    
    int main() {
        int i = 5;
        
        printf("While loop:\n");
        // This loop will not execute because i is not < 5
        while (i < 5) {
            printf("i = %d\n", i);
            i++;
        }
        
        printf("Do-while loop:\n");
        // This loop will execute once because the check is at the end
        do {
            printf("i = %d\n", i);
            i++;
        } while (i < 5);
        
        return 0;
    }
    ```
    **Output:**
    ```
    While loop:
    Do-while loop:
    i = 5
    ```
    This example clearly shows that the `do-while` loop ran once even when the condition was false, while the `while` loop did not.

2.  **What do you understand by call by value and call by reference in function? Describe it with proper example.**

    (This is the same as Question 7 from the first exam's Section B. See answer above for a detailed explanation and code example.)

3.  **Describe why storage classes are used in C programming language. Explain static and external storage class with example.**

    **Why Storage Classes are Used:**
    Storage classes are used in C to determine the scope, lifetime, and initial value of variables and functions. They tell the compiler where to store a variable (e.g., in memory or a CPU register), its visibility across the program, and how long it should exist.

    1.  **`static` Storage Class:**
        *   **Lifetime:** A `static` local variable exists for the entire lifetime of the program, just like a global variable. However, its scope is still limited to the function in which it is declared.
        *   **Persistence:** Its value is preserved between function calls.
        *   **Initialization:** It is initialized only once, to zero by default.
        **Example:**
        ```c
        #include <stdio.h>
        void counter() {
            static int count = 0; // Initialized only once
            count++;
            printf("Count = %d\n", count);
        }
        int main() {
            counter(); // Prints 1
            counter(); // Prints 2 (value was preserved)
            return 0;
        }
        ```
    2.  **`extern` (External) Storage Class:**
        *   **Scope:** The `extern` keyword is used to declare a global variable that is defined in another file. It tells the compiler that the variable exists somewhere else, so no memory is allocated. It extends the visibility of a variable to multiple source files.
        *   **Lifetime:** Same as a global variable (the entire program execution).
        **Example:**
        *File1.c*
        ```c
        #include <stdio.h>
        int global_var = 100; // Definition
        ```
        *File2.c*
        ```c
        #include <stdio.h>
        extern int global_var; // Declaration (tells compiler it's in another file)
        void display() {
            printf("Value from other file: %d\n", global_var);
        }
        ```

4.  **What is string constant? How string constant differ from character constant?**

    (This is the same as Question 6 from the first exam paper. See answer above.)

5.  **Describe how the for loop works. Give an example of for loop.**

    A `for` loop is an entry-controlled loop that provides a concise way to write loop structures. It combines initialization, condition checking, and increment/decrement into a single line.

    The execution procedure is as follows:
    1.  **Initialization:** This step is executed first and only once. It is used to declare and initialize any loop control variables.
    2.  **Condition:** The condition is evaluated. If it is true, the body of the loop is executed. If it is false, the loop terminates.
    3.  **Loop Body:** If the condition is true, the statements inside the loop's body are executed.
    4.  **Increment/Decrement:** After the loop body is executed, this step is performed to update the loop control variable.
    5.  The control then jumps back to Step 2 (Condition), and the process repeats.

    **Example:** A program to print numbers from 1 to 5.
    ```c
    #include <stdio.h>
    
    void main() {
        int i;
        
        // 1. Initialization: i = 1
        // 2. Condition: i <= 5
        // 4. Increment: i++
        for (i = 1; i <= 5; i++) {
            // 3. Loop Body
            printf("%d ", i);
        }
    }
    ```
    **Output:** `1 2 3 4 5`

6.  **Describe several different types of operators that are included in C.**
    
    C includes a rich set of operators, which can be classified as follows:
    *   **Arithmetic Operators:** Used for mathematical calculations. Examples: `+` (addition), `-` (subtraction), `*` (multiplication), `/` (division), `%` (modulus). *(Page 36)*
    *   **Relational Operators:** Used to compare two values. They return either true (1) or false (0). Examples: `==` (equal to), `!=` (not equal to), `>` (greater than), `<` (less than), `>=` (greater than or equal to), `<=` (less than or equal to). *(Page 38)*
    *   **Logical Operators:** Used to combine or reverse logical expressions. Examples: `&&` (logical AND), `||` (logical OR), `!` (logical NOT). *(Page 38)*
    *   **Assignment Operators:** Used to assign values to variables. Examples: `=` (simple assignment), `+=`, `-=`, `*=`, `/=`. *(Page 39)*
    *   **Increment/Decrement Operators:** Used to increase or decrease a variable's value by one. Examples: `++` (increment), `--` (decrement). *(Page 36)*
    *   **Bitwise Operators:** Used to perform operations on individual bits of data. Examples: `&` (bitwise AND), `|` (bitwise OR), `^` (bitwise XOR).

7.  **List out the advantages and disadvantages of functions? What is meant by function argument, function call and return value?**
    
    **Advantages of Functions:**
    *   **Modularity:** Breaks down a program into smaller, manageable parts.
    *   **Reusability:** Code can be written once and used many times.
    *   **Easier Debugging:** It's easier to find and fix errors in small, independent functions.
    *   **Readability:** A modular program is easier to read and understand.

    **Disadvantages of Functions:**
    *   **Execution Time:** Function calls have a small overhead (pushing arguments to the stack, etc.), which can slightly slow down a program compared to in-line code.
    *   **Memory Usage:** Each function call adds an entry to the program's call stack, consuming memory. Excessive recursion can lead to a stack overflow.

    **Function Argument, Call, and Return Value:**
    (This is the same as Question 4 from the first exam's Section B. See answer above.)

8.  **Write a program to print all prime numbers from 1 to 50.**
    
    ```c
    #include <stdio.h>
    
    int main() {
        int i, j, N = 50, isPrime;
    
        printf("Prime numbers from 1 to %d are:\n", N);
    
        // Loop through each number from 2 up to N
        for (i = 2; i <= N; i++) {
            // Assume the number is prime initially
            isPrime = 1;
    
            // Check for factors from 2 up to i/2
            for (j = 2; j <= i / 2; j++) {
                // If a factor is found, it's not a prime number
                if (i % j == 0) {
                    isPrime = 0;
                    break; // Exit the inner loop
                }
            }
    
            // If isPrime is still 1, then the number is prime
            if (isPrime == 1) {
                printf("%d ", i);
            }
        }
        
        printf("\n");
        return 0;
    }
    ```
    **Output:**
    ```
    Prime numbers from 1 to 50 are:
    2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 
    ```